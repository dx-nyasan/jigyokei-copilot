# Cloud Runデプロイ戦記：根本原因分析のケーススタディ

## 概要

- **日時:** 2024年10月26日
- **対象サービス:** `jigyokei-copilot-backend` (FastAPIアプリケーション)
- **課題:** ローカル環境では正常に動作するアプリケーションが、Cloud Runへのデプロイに繰り返し失敗する。
- **最終的なエラーメッセージ:** `Revision '...' is not ready and cannot serve traffic. The user-provided container failed to start and listen on the port defined provided by the PORT=8080 environment variable...`

## 問題解決までの道のり

### 仮説1: ポートの不一致

- **症状:** エラーメッセージから、Cloud Runが指定する`PORT`環境変数（通常8080）をリッスンできていないと推測。
- **施策:** `main.py`と`Dockerfile`を修正し、`PORT`環境変数を明示的に読み込むベストプラクティスを適用。
- **結果:** **失敗。** エラーは変わらず。問題の根は他にあると判断。

### 仮説2: 環境変数（APIキー）の欠落

- **症状:** アプリがポートをリッスンする前にクラッシュしていると推測。起動時に読み込まれる`GOOGLE_API_KEY`がCloud Run環境に存在しないことが原因という仮説を立てる。
- **施策:** ユーザーの指摘に基づき、既存のSecret Managerのシークレット (`jigyokei-copilot-api-key`) を `--set-secrets` フラグでCloud Runに連携。
- **結果:** **失敗。** 途中でフラグの構文ミスもあったが、それを修正しても同じポートエラーで失敗。これにより、APIキーの受け渡し方法も根本原因ではないと判断。

### 仮説3（根本原因）: アプリケーションの依存関係の欠落

- **症状:** ポートと環境変数の設定がベストプラクティスに則っているにも関わらず失敗するため、アプリケーション自体が起動に失敗していると断定。
- **調査:** 全ての基本に立ち返り、Pythonアプリケーションの依存関係を定義する `requirements.txt` を確認。
- **発見:** `google-generativeai` のみが記載されており、APIサーバーの基盤である **`fastapi`** と **`uvicorn`** が欠落していた。
- **結論:** コンテナがビルドされた後、`python main.py`が実行されるが、`from fastapi import FastAPI` という最初のコードを読み込んだ時点でライブラリが見つからず、アプリケーションが即座にクラッシュしていた。Cloud Runは「アプリがクラッシュした」とは報告せず、「結果としてポートで待機できなかった」という表面的なエラーを出していた。

## 最終的な解決策

1.  `requirements.txt` に、不足していた `fastapi`, `uvicorn`, `pydantic` を追記。
2.  修正した `requirements.txt` を含め、正しい `--set-secrets` フラグを付けたコマンドで再デプロイ。
3.  **結果: デプロイ成功。**

## 教訓（未来への情報資産）

1.  **エラーメッセージの裏を読む:** 「ポートでリッスンできない」というCloud Runのエラーは、多くの場合、**アプリケーションがその段階に到達する前にクラッシュしている**サインである。ポート設定そのものだけでなく、アプリの起動シーケンス全体を疑うべき。
2.  **基本に立ち返る:** 複雑なプラットフォーム固有の問題（ポート、IAM、環境変数）に飛びつく前に、最も基本的な構成要素（`requirements.txt` や `package.json` など）が完全であるかを確認する。**「ビルド成功」は「動作保証」ではない。**
3.  **最小構成での検証:** `main.py` の中身を `print("Hello World")` だけにするなど、極端にシンプルな状態でデプロイしてみることも、問題の切り分け（プラットフォームの問題か、コードの問題か）に有効である。
