{"files":[{"id":"60aee913-dffc-4d43-a451-f1c4a177bda3","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Etc/GMT-9\",\n  \"dependencies\": {\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"4142555a-ebb6-4d76-ae36-e01257634625","name":"コード","type":"server_js","source":"/**\n * @fileoverview プロジェクトJSONファイル群を安全かつ効率的に更新・資産化するための公式エンジン\n * @version 5.0 (バックエンド構築フェーズ完了)\n * @description マスタープラン、プロジェクト状態、意思決定ログの3ファイルを対象に、Deltas（差分）とSnapshots（全体）のアーカイブ戦略を実装。\n */\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// グローバル設定（ご自身の環境に合わせて変更してください）\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n// ▼▼▼【要設定】▼▼▼\nconst MASTER_FOLDER_ID \u003d \"1VK3Y3uFwgxdoVTiDSkl5SS6lGnla90P4\"; // マスターJSONファイル群が格納されているフォルダID\nconst ARCHIVE_FOLDER_ID \u003d \"1sVHBxUqJj7fN9uVgw8AGo1hhXlhTWiQw\"; // アーカイブ（Deltas, Snapshots）を保存するフォルダID\n// ▲▲▲▲▲▲▲▲▲▲▲▲\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ▼▼▼【処理の心臓部】個別の更新関数から呼び出される共通更新エンジン ▼▼▼\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n/**\n * 設定オブジェクトに基づき、複数のJSONファイルを安全に更新するメイン関数\n * （差分バックアップ作成と本体更新を一体で実行）\n * @param {object} config - 更新内容を定義した設定オブジェクト\n */\nfunction applyProjectUpdate(config) {\n  const masterFolder \u003d DriveApp.getFolderById(MASTER_FOLDER_ID);\n  const archiveFolder \u003d DriveApp.getFolderById(ARCHIVE_FOLDER_ID);\n  \n  let deltasFolder;\n  const deltasFolders \u003d archiveFolder.getFoldersByName(\"Deltas\");\n  deltasFolder \u003d deltasFolders.hasNext() ? deltasFolders.next() : archiveFolder.createFolder(\"Deltas\");\n\n  const timestamp \u003d new Date().toISOString().replace(/[:.]/g, \u0027-\u0027);\n  const filesToUpdate \u003d Object.keys(config.updates);\n\n  try {\n    // 1. 変更対象のファイルをDeltasフォルダにバックアップ\n    filesToUpdate.forEach(fileName \u003d\u003e {\n      const files \u003d masterFolder.getFilesByName(fileName);\n      if (files.hasNext()) {\n        const file \u003d files.next();\n        const backupFileName \u003d `${timestamp}_${fileName}`;\n        file.makeCopy(backupFileName, deltasFolder);\n        Logger.log(`\u0027${fileName}\u0027 の変更前バージョンを \u0027${backupFileName}\u0027 としてDeltasに保存しました。`);\n      }\n    });\n\n    // 2. 全てのファイルを更新\n    filesToUpdate.forEach(fileName \u003d\u003e {\n      const targetFiles \u003d masterFolder.getFilesByName(fileName);\n      let fileObject \u003d {}; \n\n      if (targetFiles.hasNext()) {\n        const file \u003d targetFiles.next();\n        const content \u003d file.getBlob().getDataAsString();\n        if (content) {\n          // JSONファイル以外はそのまま文字列として扱う\n          if (fileName.toLowerCase().endsWith(\u0027.json\u0027)) {\n            fileObject \u003d JSON.parse(content);\n          } else {\n            fileObject \u003d content;\n          }\n        }\n      }\n\n      const updatedObject \u003d config.updates[fileName](fileObject);\n      \n      let newContent;\n      if (typeof updatedObject \u003d\u003d\u003d \u0027string\u0027) {\n        newContent \u003d updatedObject;\n      } else {\n        newContent \u003d JSON.stringify(updatedObject, null, 2);\n      }\n\n      const filesForUpdate \u003d masterFolder.getFilesByName(fileName);\n      if (filesForUpdate.hasNext()) {\n          filesForUpdate.next().setContent(newContent);\n          Logger.log(`\u0027${fileName}\u0027 を正常に更新しました。`);\n      } else {\n          masterFolder.createFile(fileName, newContent);\n          Logger.log(`\u0027${fileName}\u0027 を新規作成しました。`);\n      }\n    });\n\n    Logger.log(`✅ すべての更新処理が正常に完了しました。`);\n\n  } catch (error) {\n    Logger.log(`❌ エラーが発生しました: ${error.toString()}`);\n    Logger.log(`エラー詳細: ${error.stack}`);\n    Logger.log(`更新処理は中断されました。Deltasフォルダ内のバックアップを確認してください。`);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ▼▼▼【手動実行用】任意のタイミングで全体をバックアップする関数 ▼▼▼\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n/**\n * 現在のすべてのマスターファイルをSnapshotsフォルダに保存する関数\n */\nfunction createSnapshot() {\n  const masterFolder \u003d DriveApp.getFolderById(MASTER_FOLDER_ID);\n  const archiveFolder \u003d DriveApp.getFolderById(ARCHIVE_FOLDER_ID);\n\n  let snapshotsFolder;\n  const snapshotFolders \u003d archiveFolder.getFoldersByName(\"Snapshots\");\n  snapshotsFolder \u003d snapshotFolders.hasNext() ? snapshotFolders.next() : archiveFolder.createFolder(\"Snapshots\");\n  \n  const timestamp \u003d new Date().toISOString().replace(/[:.]/g, \u0027-\u0027);\n  const snapshotName \u003d `Snapshot_${timestamp}`;\n  const newSnapshotFolder \u003d snapshotsFolder.createFolder(snapshotName);\n  \n  Logger.log(`スナップショットフォルダ \u0027${snapshotName}\u0027 を作成しました。`);\n\n  const files \u003d masterFolder.getFiles();\n  while(files.hasNext()){\n    const file \u003d files.next();\n    file.makeCopy(file.getName(), newSnapshotFolder);\n  }\n  \n  Logger.log(`✅ \u0027${snapshotName}\u0027 に現在の全マスターファイルのスナップショットを作成しました。`);\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// ▼▼▼【更新実行用】特定の更新内容を適用する関数群 ▼▼▼\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n/*\n * 運用ルール：\n * 1. 新しい更新を追加する際は、このセクションの一番下に新しい`updateConfig_...`と`runUpdate_...`のセットを追記します。\n * 2. 追記したら、今まで有効だった（アンダースコア \"_\" が付いていなかった）古い方の runUpdate 関数の名前の先頭に \"_\" を付けてアーカイブします。\n * 3. これにより、実行メニューには常に新しく追加した、まだ実行していない関数が１つだけ表示され、誤操作を防ぎます。\n */\n\n// ---------------------------------------------------------------------------------\n// ▼▼▼ アーカイブ済みの更新履歴 ▼▼▼\n// （実行メニューには表示されません）\n// ---------------------------------------------------------------------------------\n\n// 【更新履歴1】〜【更新履歴14】は省略\n\n// 【更新履歴15】（アーカイブ済み）\nconst updateConfig_CreateDevLogPhase2 \u003d { /* ... 内容は省略 ... */ };\nfunction _runUpdate_CreateDevLogPhase2() {\n  applyProjectUpdate(updateConfig_CreateDevLogPhase2);\n}\n\n\n// ---------------------------------------------------------------------------------\n// ▼▼▼【今回実行する唯一の関数】▼▼▼\n// （新しい更新を追加したら、この関数の名前を `_runUpdate...` に変更してください）\n// ---------------------------------------------------------------------------------\n\n/**\n * 💡 この関数を実行してください\n * 【更新履歴16】バックエンド構築フェーズの完了と次フェーズへの移行\n */\nconst updateConfig_FinalizeBackendPhase \u003d {\n  updateName: \"Finalize_Backend_Development_Phase_And_Transition_To_Next\",\n  updates: {\n    \"マスタープラン.JSON\": function(currentPlan) {\n      const BACKEND_URL \u003d \"https://jigyokei-copilot-backend-310523847405.asia-northeast2.run.app\";\n\n      // 1. 機能ブロックにエンドポイントURLを追記\n      const backendBlock \u003d currentPlan.systemArchitecture.functionalBlocks.find(b \u003d\u003e b.priority \u003d\u003d\u003d 1);\n      if (backendBlock) {\n        backendBlock.status \u003d \"完了\";\n        backendBlock.endpointURL \u003d BACKEND_URL;\n      }\n\n      // 2. ロードマップのステータスを更新\n      const phase1 \u003d currentPlan.roadmap.find(p \u003d\u003e p.phase \u003d\u003d\u003d 1);\n      if (phase1) {\n        phase1.status \u003d \"完了\";\n        phase1.title \u003d \"【完了】バックエンド構築フェーズ\";\n      }\n\n      const phase2 \u003d currentPlan.roadmap.find(p \u003d\u003e p.phase \u003d\u003d\u003d 2);\n      if (phase2) {\n        phase2.status \u003d \"進行中\";\n        phase2.title \u003d \"【進行中】データベースとGUIの連携開発フェーズ\";\n      }\n\n      // 3. 最終更新日時を更新\n      currentPlan.lastModified \u003d new Date().toISOString();\n      return currentPlan;\n    },\n    \"意思決定ログ.JSON\": function(currentLog) {\n      const now \u003d new Date();\n      const timestamp \u003d now.toISOString();\n      const logId \u003d `LOG-${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, \u00270\u0027)}${now.getDate().toString().padStart(2, \u00270\u0027)}-${Date.now().toString().slice(-5)}`;\n      \n      const newLogEntry \u003d {\n        \"logId\": logId,\n        \"timestamp\": timestamp,\n        \"subject\": \"バックエンド構築フェーズの公式な完了を宣言\",\n        \"context_why\": \"バックエンドAPIのCloud Runへのデプロイが成功し、全世界からアクセス可能な恒久的なエンドポイントURLが確保されたため。\",\n        \"decision_what\": \"バックエンド構築フェーズ（ロードマップのフェーズ1）の完了を正式に決定。成功の証として、デプロイされたURLをマスタープランに記録し、プロジェクトのステータスを次なる『データベースとGUIの連携開発フェーズ』へと進める。\",\n        \"impact_how\": \"プロジェクトの基盤となるサーバーサイド機能が完全に確立された。これにより、今後はフロントエンド（GUI）からのデータを受け取り、それを処理して返すという、アプリケーションの核心的な価値提供に集中できるようになった。\"\n      };\n      if (!currentLog.decisionLog) currentLog.decisionLog \u003d { logs: [] };\n      currentLog.decisionLog.logs.push(newLogEntry);\n      currentLog.decisionLog.最終更新日 \u003d timestamp;\n      return currentLog;\n    },\n    \"プロジェクト状態.JSON\": function(currentStatus) {\n      const now \u003d new Date().toISOString();\n      if (!currentStatus.projectStatus) currentStatus.projectStatus \u003d {};\n      const status \u003d currentStatus.projectStatus;\n\n      status.最終更新日 \u003d now;\n      status.status \u003d \"バックエンド構築完了・連携開発フェーズ\";\n      status.lastCompletedMilestone \u003d \"バックエンドAPIのデプロイに成功し、マスタープランのロードマップを更新。プロジェクトは正式に次の開発フェーズへ移行した。\";\n      status.nextActionableStep \u003d \"フロントエンド（GUI）と、今回デプロイしたバックエンドAPIとの間で、データの送受信を行う連携部分の開発に着手する。\";\n      return currentStatus;\n    }\n  }\n};\n/**\n * 💡 この関数を実行してください\n */\nfunction runUpdate_FinalizeBackendPhase() {\n  applyProjectUpdate(updateConfig_FinalizeBackendPhase);\n}"}]}